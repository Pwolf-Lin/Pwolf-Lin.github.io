<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Python3实现多进程池调用exe文件执行</title>
    <link href="/2023/06/01/Python3%E5%AE%9E%E7%8E%B0%E5%A4%9A%E8%BF%9B%E7%A8%8B%E6%B1%A0%E8%B0%83%E7%94%A8exe%E6%96%87%E4%BB%B6%E6%89%A7%E8%A1%8C/"/>
    <url>/2023/06/01/Python3%E5%AE%9E%E7%8E%B0%E5%A4%9A%E8%BF%9B%E7%A8%8B%E6%B1%A0%E8%B0%83%E7%94%A8exe%E6%96%87%E4%BB%B6%E6%89%A7%E8%A1%8C/</url>
    
    <content type="html"><![CDATA[<h1 id="python3实现多进程池调用exe文件执行"><a href="#python3实现多进程池调用exe文件执行" class="headerlink" title="python3实现多进程池调用exe文件执行"></a>python3实现多进程池调用exe文件执行</h1><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>最近计算的工况太多了，计算集群的slurm作业系统也太拉垮了，一台96核的计算机，用了24核后，剩下的核心就只能睡觉了。一直知道python可以是实现多进程，也没空写，现在计算的工况有点多，不写不行了。于是根据CFDEM的程序计算过程修改配置文件完成的，具体过程不详细说了，直接看代码吧。</p><h3 id="代码部分"><a href="#代码部分" class="headerlink" title="代码部分"></a>代码部分</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># -*- coding: utf-8 -*-</span><br><span class="hljs-comment"># job_multiLoad.py</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">execute_mpiexec</span>(<span class="hljs-params">ncore,ipath</span>):<br>    os.chdir(ipath)<br>    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;output.log&#x27;</span>, <span class="hljs-string">&#x27;w&#x27;</span>) <span class="hljs-keyword">as</span> output_file:<br>        subprocess.call([<span class="hljs-string">&#x27;mpiexec&#x27;</span>, <span class="hljs-string">&#x27;-n&#x27;</span>,<span class="hljs-built_in">str</span>(ncore), <span class="hljs-string">&#x27;../exe/HSTAR_CFDEM.exe&#x27;</span>], stdout=output_file)<br>    os.chdir(<span class="hljs-string">&#x27;..&#x27;</span>)<br><br><span class="hljs-comment"># 分区</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">partition</span>(<span class="hljs-params">pathlist</span>):<br>    num = <span class="hljs-number">1</span><br>    <span class="hljs-keyword">for</span> ipath <span class="hljs-keyword">in</span> pathlist:<br>        os.chdir(ipath)<br>        allfiles = os.listdir()<br>        subfolder = [name <span class="hljs-keyword">for</span> name <span class="hljs-keyword">in</span> allfiles <span class="hljs-keyword">if</span> os.path.isdir(os.path.join(<span class="hljs-string">&#x27;.&#x27;</span>, name))]<br>        <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">f&#x27;input.txt&#x27;</span>, <span class="hljs-string">&#x27;r&#x27;</span>) <span class="hljs-keyword">as</span> file:<br>            lines = file.readlines() <br>        <span class="hljs-keyword">if</span>(platform.system()==<span class="hljs-string">&#x27;Linux&#x27;</span>): lines[-<span class="hljs-number">3</span>] = <span class="hljs-string">f&#x27;&quot;./<span class="hljs-subst">&#123;subfolder[<span class="hljs-number">0</span>]&#125;</span>/1&quot;\n&#x27;</span> <span class="hljs-comment">#以文件夹命名</span><br>        <span class="hljs-comment"># if(platform.system()==&#x27;Windows&#x27;): lines[-3] = f&#x27;&#123;subfolder[0]&#125;\\1\n&#x27;</span><br>        lines[-<span class="hljs-number">5</span>]= <span class="hljs-string">f&#x27;2  <span class="hljs-subst">&#123;ncore&#125;</span>  0 \n&#x27;</span><br>        <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">f&#x27;input.txt&#x27;</span>, <span class="hljs-string">&#x27;w&#x27;</span>) <span class="hljs-keyword">as</span> file:<br>            file.writelines(lines)<br>        os.chdir(<span class="hljs-string">&#x27;..&#x27;</span>) <br>    <span class="hljs-comment">#各自进行分区</span><br>    <span class="hljs-keyword">with</span> ProcessPoolExecutor(max_workers=nworker) <span class="hljs-keyword">as</span> executor:<br>        futures = [executor.submit(execute_mpiexec, num, ipath) <span class="hljs-keyword">for</span> ipath <span class="hljs-keyword">in</span> pathlist]<br>        <span class="hljs-keyword">for</span> future <span class="hljs-keyword">in</span> futures:<br>            future.result()<br>        <span class="hljs-comment"># if(ncore !=1):subprocess.run(f&#x27;../exe/HSTAR_CFDEM.exe&#x27;, cwd=&#x27;.&#x27;, shell=True)</span><br><br><span class="hljs-comment"># 并行input</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">inputForParallel</span>(<span class="hljs-params">pathlist</span>):<br>    <span class="hljs-keyword">for</span> ipath <span class="hljs-keyword">in</span> pathlist:<br>        os.chdir(ipath)<br>        <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">f&#x27;input.txt&#x27;</span>, <span class="hljs-string">&#x27;r&#x27;</span>) <span class="hljs-keyword">as</span> file:<br>            lines = file.readlines() <br>        lines[-<span class="hljs-number">5</span>]= <span class="hljs-string">f&#x27;1  <span class="hljs-subst">&#123;ncore&#125;</span>  0 \n&#x27;</span> <br>        <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">f&#x27;input.txt&#x27;</span>, <span class="hljs-string">&#x27;w&#x27;</span>) <span class="hljs-keyword">as</span> file:<br>            file.writelines(lines) <br>        os.chdir(<span class="hljs-string">&#x27;..&#x27;</span>) <br>    <span class="hljs-keyword">return</span><br><br><span class="hljs-comment"># 串行input</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">inputForSerial</span>(<span class="hljs-params">pathlist</span>):<br>    <span class="hljs-keyword">for</span> ipath <span class="hljs-keyword">in</span> pathlist:<br>        os.chdir(ipath)<br>        allfiles = os.listdir()<br>        subfolder = [name <span class="hljs-keyword">for</span> name <span class="hljs-keyword">in</span> allfiles <span class="hljs-keyword">if</span> os.path.isdir(os.path.join(<span class="hljs-string">&#x27;.&#x27;</span>, name))]<br>        <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">f&#x27;input.txt&#x27;</span>, <span class="hljs-string">&#x27;r&#x27;</span>) <span class="hljs-keyword">as</span> file:<br>            lines = file.readlines() <br>        lines[-<span class="hljs-number">3</span>] = <span class="hljs-string">f&#x27;&quot;./<span class="hljs-subst">&#123;subfolder[<span class="hljs-number">0</span>]&#125;</span>/1&quot;\n&#x27;</span> <span class="hljs-comment">#以文件夹命名</span><br>        lines[-<span class="hljs-number">5</span>]= <span class="hljs-string">f&#x27;0  1  0 \n&#x27;</span><br>        <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">f&#x27;input.txt&#x27;</span>, <span class="hljs-string">&#x27;w&#x27;</span>) <span class="hljs-keyword">as</span> file:<br>            file.writelines(lines) <br>        os.chdir(<span class="hljs-string">&#x27;..&#x27;</span>) <br>    <span class="hljs-keyword">return</span><br><br><span class="hljs-comment"># # 合并结果</span><br><span class="hljs-comment"># def combineRes(pathlist):</span><br><br><span class="hljs-comment">#     return</span><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br><br>    pathlist = [<span class="hljs-string">&#x27;0.1&#x27;</span>,<span class="hljs-string">&#x27;0.2&#x27;</span>] <span class="hljs-comment">#工况计算文件夹，数量=nworker</span><br>    nworker = <span class="hljs-built_in">len</span>(pathlist) <br>    ncore = <span class="hljs-number">48</span> <span class="hljs-comment">#指定核心数，串行填1</span><br>    <span class="hljs-keyword">if</span>(ncore==<span class="hljs-number">1</span>): <br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;你是要用浪潮算串行啊！？（当然此脚本也是支持96*1的）&#x27;</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;如果是，脚本将自动更新input文件，无需操作。&#x27;</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;如果不是，请取消作业，检查参数后再提交！&#x27;</span>)<br>        inputForSerial(pathlist)<br>    <span class="hljs-keyword">else</span>: <br>        partition(pathlist) <span class="hljs-comment">#分区 2</span><br>        inputForParallel(pathlist) <span class="hljs-comment"># 1</span><br>        <span class="hljs-comment"># combineRes(pathlist) # 3 #先不写，未必要算到设定时间，手动也可以合并</span><br>    <span class="hljs-keyword">with</span> ProcessPoolExecutor(max_workers=nworker) <span class="hljs-keyword">as</span> executor:<br>        futures = [executor.submit(execute_mpiexec, ncore, ipath) <span class="hljs-keyword">for</span> ipath <span class="hljs-keyword">in</span> pathlist]<br>        <span class="hljs-keyword">for</span> future <span class="hljs-keyword">in</span> futures:<br>            future.result()<br></code></pre></td></tr></table></figure><p>注意要将slurm作业脚本要改掉了，不能用mpiexec了，要直接加载python3环境后，那行要改成 <code>python3 job_multiLoad.py</code>，核心数也要改成相应的总数，不然程序也会报错。</p><h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>上面代码里面其实有一点点瑕疵，就是设置了计算工况使用的核心数是相同的。如果不相同，其实也很容易解决，只要将ncore整成list，然后针对这个列表循环，把相应的核心数传给execute_mpiexec即可。还有一种方式，使用multiprocessing.Pool构建进程池，使用异步执行execute_mpiexec，不过ncore还是需要整成list。不改了，随缘，满足自己需求就行了。</p>]]></content>
    
    
    <categories>
      
      <category>流固耦合</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>docker容器的代理设置</title>
    <link href="/2023/05/25/docker%E7%9A%84%E4%BB%A3%E7%90%86%E8%AE%BE%E7%BD%AE/"/>
    <url>/2023/05/25/docker%E7%9A%84%E4%BB%A3%E7%90%86%E8%AE%BE%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<h1 id="docker容器的代理设置"><a href="#docker容器的代理设置" class="headerlink" title="docker容器的代理设置"></a>docker容器的代理设置</h1><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>前段时间为办公室部署完成了ChatGPT，为了端口的使用方便，不想占用太多的80端口，采用了docker部署界面，然后使用nginx反代，思路很清晰，但是在代理上设置遇到了一点困难。这里记录一下遇到的问题和最终解决方案，其实最终呢，并没有实现，但是基本上理解了原理。</p><h3 id="方案一"><a href="#方案一" class="headerlink" title="方案一"></a>方案一</h3><p>使用host模式启动容器服务。而使用 host 模式启动，Docker 容器与宿主机共享同一个网络命名空间，即 Docker 容器将直接使用宿主机的网络。这意味着 Docker 容器可以使用宿主机的 IP 地址和端口，可以直接访问宿主机上的网络服务。然而，host 模式也存在一些限制，例如 Docker 容器之间无法直接通信，Docker 容器的网络性能可能会受到影响。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker run -itd --name chatgpt --network host -e APIKEY=sk-xxxxxx -e MODEL=<span class="hljs-string">&quot;gpt-3.5-turbo&quot;</span>  -e HTTP_PROXY=<span class="hljs-string">&quot;http://127.0.0.1:1080&quot;</span>  --restart=always 镜像:latest<br></code></pre></td></tr></table></figure><p>这样容器就能直接访问到宿主机的 1080 了。但是因为这种模式的局限性，因此实际生产当中几乎没有人会用这种方式，所以不推荐使用方案一，推荐方案二。</p><h3 id="方案二"><a href="#方案二" class="headerlink" title="方案二"></a>方案二</h3><p>这个方案是docker官方提供了一种支持方案，可通过指向 <code>host.docker.internal</code> 来指向宿主机的 IP，详见<a href="https://docs.docker.com/desktop/networking/#i-want-to-connect-from-a-container-to-a-service-on-the-host">官方手册</a>：</p><p><img src="https://driver.pwolf.tk/?/images/2023/05/25/kIT0XmYbON/docker.jpg"></p><p>按照这个策略，晚上有很多这种设置方案，于是写了一个docker-compose，配置文件如下编写：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">version:</span> <span class="hljs-string">&quot;2.0&quot;</span><br><span class="hljs-attr">services:</span><br>  <span class="hljs-attr">chatgpt:</span><br>    <span class="hljs-attr">image:</span>  <span class="hljs-comment"># 镜像名，可以使用阿里云仓库的备用镜像</span><br>    <span class="hljs-attr">container_name:</span>  <span class="hljs-comment"># 容器名（可随意更改）</span><br>    <span class="hljs-attr">hostname:</span>   <span class="hljs-comment"># 主机名（可随意更改）</span><br>    <span class="hljs-attr">restart:</span> <span class="hljs-string">always</span>  <span class="hljs-comment"># 开机自启</span><br>    <span class="hljs-attr">tty:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-attr">network_mode:</span> <span class="hljs-string">bridge</span>  <span class="hljs-comment"># 容器网络类型，如果是旁路由可能需要切换为 host 类型（桥接），默认为 NAT</span><br>    <span class="hljs-attr">ports:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-number">5678</span><span class="hljs-string">:5678</span>  <span class="hljs-comment"># 端口映射，格式为 &quot;主机端口:容器端口&quot;，主机端口号可自定义，容器端口用来访问控制面板不可修改</span><br>    <span class="hljs-attr">environment:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">APIKEY=sk-xxxx</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">MODEL=&quot;gpt-3.5-turbo-0301&quot;</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">HTTP_PROXY=http://host.docker.internal:1080</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">HTTPS_PROXY=https://host.docker.internal:1080</span><br>    <span class="hljs-attr">extra_hosts:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">host.docker.internal:host-gateway</span><br></code></pre></td></tr></table></figure><p>终于部署好了，神奇的是 <code>localhost:5678</code> 打不开，这种走代理的模式居然只能后台运行。这是因为 <code>host.docker.internal</code> 是一个特殊的 DNS 名称，它只能在容器内部使用，用于访问宿主机上的服务。</p><p>后来发现可以进入容器内设置代理，于是注释掉<code>HTTP_PROXY</code>和<code>HTTPS_PROXY</code>两行，并将这两行写到容器内，用<code>export</code>写到<code>~/.bashrc</code>或者<code>/etc/profile</code>中，这样也可以解决问题。</p>]]></content>
    
    
    <categories>
      
      <category>学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Azure的ChatGPT客户端搭建</title>
    <link href="/2023/05/19/Azure%E7%9A%84ChatGPT%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%90%AD%E5%BB%BA/"/>
    <url>/2023/05/19/Azure%E7%9A%84ChatGPT%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%90%AD%E5%BB%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="Azure的ChatGPT客户端搭建"><a href="#Azure的ChatGPT客户端搭建" class="headerlink" title="Azure的ChatGPT客户端搭建"></a>Azure的ChatGPT客户端搭建</h1><h3 id="说明几点："><a href="#说明几点：" class="headerlink" title="说明几点："></a>说明几点：</h3><blockquote><p><strong>主要使用的是微软的OpenAI和chatGPT-Next-Web客户端</strong></p><ul><li>详细申请注册过程参照博客园中的一篇<a href="https://www.cnblogs.com/qsing/p/17362395.html">文章</a>，里面有详细的申请过程；</li><li>关于申请完成后的相关配置，参见<a href="https://atlassc.net/2023/04/25/azure-openai-service">ShinChven’s Blog</a>，里面详细记载了作者的申请和配置；</li><li><a href="https://github.com/Yidadaa/ChatGPT-Next-Web">ChatGPT-Next-Web客户端</a>具有良好的交互界面，比chathub等客户端方便的多，还可以安装本地的浏览器app，手机网页版也可以直接连过去。</li></ul></blockquote><h3 id="终结点设置（Azure-OpenAI-API）"><a href="#终结点设置（Azure-OpenAI-API）" class="headerlink" title="终结点设置（Azure OpenAI API）"></a>终结点设置（Azure OpenAI API）</h3><p>这里设置参考<a href="https://github.com/haibbo/cf-openai-azure-proxy/blob/main/README.md">cf-openai-azure-proxy</a>项目进行cloudflare部署。可能部署过程后访问出现404，403现象，貌似并不影响使用，可以直接转到azure的endpoint。</p><h3 id="ChatGPT-Next-Web客户端源码修改记录"><a href="#ChatGPT-Next-Web客户端源码修改记录" class="headerlink" title="ChatGPT-Next-Web客户端源码修改记录"></a><a href="https://github.com/Yidadaa/ChatGPT-Next-Web">ChatGPT-Next-Web客户端</a>源码修改记录</h3><p>由于<a href="https://github.com/Yidadaa/ChatGPT-Next-Web">ChatGPT-Next-Web客户端</a>主要是针对OpenAI的部署，对于Azure的OpenAI有部分冲突，这里记录一下：</p><ol><li>API Key不一样，OpenAI的key具有’sk-‘，而Azure没有，修改行数为app&#x2F;api&#x2F;common.ts中的第28行，删除’sk-‘即可：</li></ol><p><img src="https://driver.pwolf.tk/?/images/2023/05/19/KFw7LmIYGQ/28%E8%A1%8C.jpg"></p><ol start="2"><li>余额查询，Azure并不需要查询余额，所有直接删掉这一块内容。将app&#x2F;locales文件夹中的所有ts的143行至151行注释：</li></ol><p><img src="https://driver.pwolf.tk/?/images/2023/05/19/PIicbH7Z60/143.jpg"></p><ol start="3"><li>也是余额相关的，把app&#x2F;components&#x2F;settings.tsx的516行至538行注释掉：</li></ol><p><img src="https://driver.pwolf.tk/?/images/2023/05/19/nIETTrE6U6/516.jpg"></p><blockquote><p><strong>不想进一步修改界面，其实完成第一步就可以了，然后容器中部署</strong></p></blockquote><h3 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h3><ol><li>部署在docker中进行，使用了<a href="https://github.com/Yidadaa/ChatGPT-Next-Web">ChatGPT-Next-Web源码</a>中的Dockerfile文件直接构建镜像；</li><li>部署启动命令：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker run -d -p 3000:3000 -e BASE_URL=<span class="hljs-string">&#x27;上面cf项目生成的网址&#x27;</span> -e OPENAI_API_KEY=<span class="hljs-string">&quot;azure中生成的密钥&quot;</span> -e CODE=<span class="hljs-string">&quot;页面访问密码&quot;</span> 上一步构建的镜像名称<br></code></pre></td></tr></table></figure></li></ol><p>最终完成部署后的样子如下，如果需要部署网页进行反代，参见<a href="https://blog.pwolf.site/2023/04/14/nginx%E5%8F%8D%E4%BB%A3%E8%AE%BE%E7%BD%AE/">nginx反代设置</a>。</p><p><img src="https://driver.pwolf.tk/?/images/2023/05/19/tCCwkOOrWi/end.jpg"></p>]]></content>
    
    
    <categories>
      
      <category>学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>ChatGPT</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>nginx反代设置</title>
    <link href="/2023/04/14/nginx%E5%8F%8D%E4%BB%A3%E8%AE%BE%E7%BD%AE/"/>
    <url>/2023/04/14/nginx%E5%8F%8D%E4%BB%A3%E8%AE%BE%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<p>一直习惯于使用宝塔的控制面板，最近发现暴露出弊端，不仅仅是网络上说的安全问题，同时自己的服务器属于底层低配机器，根本折腾不来宝塔，加上宝塔虽然方便，但是不明白具体配置文件编写，在这里记录一下：</p><h2 id="主要是修改-x2F-etc-x2F-nginx-x2F-nginx-conf"><a href="#主要是修改-x2F-etc-x2F-nginx-x2F-nginx-conf" class="headerlink" title="主要是修改&#x2F;etc&#x2F;nginx&#x2F;nginx.conf"></a>主要是修改&#x2F;etc&#x2F;nginx&#x2F;nginx.conf</h2><figure class="highlight htmlbars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs htmlbars"><span class="language-xml"># 反代docker开的网站</span><br><span class="language-xml">server &#123;</span><br><span class="language-xml">    listen  80;</span><br><span class="language-xml">    server_name 域名(website);</span><br><span class="language-xml">    location / &#123;</span><br><span class="language-xml">            proxy_pass http://127.0.0.1:81;</span><br><span class="language-xml">            proxy_buffering off; # 防止一大段输出（这里主要是配置chatGPT客户端中打字机效果）</span><br><span class="language-xml">            proxy_set_header Host $proxy_host; # 修改转发请求头，让端口的应用可以受到真实的请求</span><br><span class="language-xml">            proxy_set_header X-Real-IP $remote_addr;</span><br><span class="language-xml">            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="language-xml">    &#125;</span><br><span class="language-xml">    # 防止爬虫抓取</span><br><span class="language-xml">    if ($http_user_agent ~* &quot;360Spider|JikeSpider|Spider|spider|bot|Bot|2345Explorer|curl|wget|webZIP|qihoobot|Baiduspider|Googlebot|Googlebot-Mobile|Googlebot-Image|Mediapartners-Google|Adsbot-Google|Feedfetcher-Google|Yahoo! Slurp|Yahoo! Slurp China|YoudaoBot|Sosospider|Sogou spider|Sogou web spider|MSNBot|ia_archiver|Tomato Bot|NSPlayer|bingbot&quot;) &#123;</span><br><span class="language-xml">    return 403;</span><br><span class="language-xml">    &#125;</span><br><span class="language-xml">&#125;</span><br><span class="language-xml">server &#123;</span><br><span class="language-xml">    listen 80;</span><br><span class="language-xml">    server_name 域名(website);</span><br><span class="language-xml">    location / &#123;</span><br><span class="language-xml">            proxy_pass http://127.0.0.1:82;</span><br><span class="language-xml">            proxy_set_header Host $proxy_host; # 修改转发请求头，让端口的应用可以受到真实的请求</span><br><span class="language-xml">            proxy_set_header X-Real-IP $remote_addr;</span><br><span class="language-xml">            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="language-xml">    &#125;</span><br><span class="language-xml">&#125;</span><br></code></pre></td></tr></table></figure><p>将里面的端口号和域名(website)修改成对应的网址和端口即可，最后需要重置配置文件：</p><blockquote><p><strong>nginx -s reload</strong></p></blockquote><h2 id="证书申请"><a href="#证书申请" class="headerlink" title="证书申请"></a>证书申请</h2><p>nginx占用了80端口，申请证书时可以先关闭nginx，然后进行acme申请：</p><blockquote><p><strong>acme.sh –issue -d 域名 –standalone -k ec-256</strong></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>python实现坐标点的系统转换</title>
    <link href="/2023/04/04/python%E5%AE%9E%E7%8E%B0%E5%9D%90%E6%A0%87%E7%82%B9%E7%9A%84%E7%B3%BB%E7%BB%9F%E8%BD%AC%E6%8D%A2/"/>
    <url>/2023/04/04/python%E5%AE%9E%E7%8E%B0%E5%9D%90%E6%A0%87%E7%82%B9%E7%9A%84%E7%B3%BB%E7%BB%9F%E8%BD%AC%E6%8D%A2/</url>
    
    <content type="html"><![CDATA[<p>此文已于2020年12月22日发布于<a href="https://blog.csdn.net/weixin_36135064/article/details/111562394?spm=1001.2014.3001.5502">CSDN</a></p><p>arcgis本来就不怎么会，加上好长时间没有使用，居然忘了怎么导点转坐标了，没办法，正好看到这篇文章，可以用python实现坐标系统的转换。查找了相关内容，编了一小段，可以快速实现坐标转换，十分完美！主要参见了知乎上的<a href="https://zhuanlan.zhihu.com/p/75000381">这篇文章</a>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#coding:utf-8</span><br><br><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">from</span> pyproj <span class="hljs-keyword">import</span> CRS<br><span class="hljs-keyword">from</span> pyproj <span class="hljs-keyword">import</span> Transformer<br><br><br>from_crs = CRS.from_epsg(<span class="hljs-number">4326</span>)  <span class="hljs-comment">#坐标系统从下面这个网址查询</span><br>to_crs = CRS.from_epsg(<span class="hljs-number">32649</span>)   <span class="hljs-comment">#https://developers.arcgis.com/javascript/3/jshelp/pcs.htm</span><br>input_file = <span class="hljs-string">&quot;./point.txt&quot;</span><br>output_file = <span class="hljs-string">&quot;./output.txt&quot;</span><br>transformer = Transformer.from_crs(from_crs,to_crs,always_xy=<span class="hljs-literal">True</span>)<br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(output_file,<span class="hljs-string">&quot;w&quot;</span>) <span class="hljs-keyword">as</span> fo:<br>    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(input_file,<span class="hljs-string">&quot;r&quot;</span>) <span class="hljs-keyword">as</span> fi:<br>        <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>            line = fi.readline()     <span class="hljs-comment"># 逐行读取</span><br>            array=line.split()<br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> line:<br>                <span class="hljs-keyword">break</span><br>            <span class="hljs-keyword">else</span>:<br>                data = [ <span class="hljs-built_in">float</span>(x) <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> array[<span class="hljs-number">1</span>:] ]<br>                <span class="hljs-built_in">print</span>(data)<br>                lon = data[<span class="hljs-number">0</span>]<br>                lat = data[<span class="hljs-number">1</span>]<br>                x,y = transformer.transform(lon,lat)<br>                fo.write(<span class="hljs-string">&quot;\t&quot;</span>.join([<span class="hljs-string">&quot;&#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(array[<span class="hljs-number">0</span>]),<span class="hljs-string">&quot;&#123;:.6f&#125;&quot;</span>.<span class="hljs-built_in">format</span>(x),<span class="hljs-string">&quot;&#123;:.6f&#125;&quot;</span>.<span class="hljs-built_in">format</span>(y),<span class="hljs-string">&#x27;\n&#x27;</span>]))<br>            <br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;All Done&#x27;</span>)<br></code></pre></td></tr></table></figure><p>这是与arcgis转的结果的对比图：</p><p><img src="https://driver.pwolf.tk/images/2023/04/04/xF6AQ4pNWD/compare.jpg"></p>]]></content>
    
    
    <categories>
      
      <category>学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>nc地形数据的python转换实现tiff</title>
    <link href="/2023/04/04/nc%E5%9C%B0%E5%BD%A2%E6%95%B0%E6%8D%AE%E7%9A%84python%E8%BD%AC%E6%8D%A2%E5%AE%9E%E7%8E%B0tiff/"/>
    <url>/2023/04/04/nc%E5%9C%B0%E5%BD%A2%E6%95%B0%E6%8D%AE%E7%9A%84python%E8%BD%AC%E6%8D%A2%E5%AE%9E%E7%8E%B0tiff/</url>
    
    <content type="html"><![CDATA[<p>此文已于2020年7月21日发布于<a href="https://blog.csdn.net/weixin_36135064/article/details/107498637?spm=1001.2014.3001.5502">CSDN</a></p><p>之前做的一个海底地形的数据导入arcgis的问题，由于是全球的地形数据（精度为15弧秒），从<a href="https://www.gebco.net/data_and_products/gridded_bathymetry_data">GEBCO</a>下载获取，数据达到12G，在arcgis中转换也可以，但是实在是太慢，我的电脑i7-7700的转了一晚上没成功，后来看了好多arcgis的官方文档和网上的转化教程，改写成下面这一小段，速度很快，大约两小时即可完成。<br>我印象中有两篇参考的非官方文档给我提供了很大帮助，可惜找不到了，在此不能引用，但表示感谢！</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#coding=utf8</span><br><span class="hljs-comment"># Import system modules  </span><br><span class="hljs-keyword">import</span> arcpy  <br><span class="hljs-keyword">from</span> arcpy <span class="hljs-keyword">import</span> env  <br><span class="hljs-keyword">from</span> arcpy.sa <span class="hljs-keyword">import</span> *  <br><br><span class="hljs-comment"># Input data source  </span><br>arcpy.env.workspace = <span class="hljs-string">&quot;E:/ALL_change&quot;</span>  <br>arcpy.env.overwriteOutput = <span class="hljs-literal">True</span>  <br><br><span class="hljs-comment"># Set output folder  </span><br>OutputFolder = <span class="hljs-string">&quot;E:/ALL_change&quot;</span>  <br><br><span class="hljs-comment"># Loop through a list of files in the workspace  </span><br>filename = <span class="hljs-string">&quot;GEBCO_2019.nc&quot;</span>  <br><br><span class="hljs-comment">#for filename in NCfiles:  </span><br><br><span class="hljs-comment">#print(&quot;Processing: &quot; + filename)  </span><br><br>inNCfiles = arcpy.env.workspace + <span class="hljs-string">&quot;/&quot;</span> + filename  <br>fileroot = <span class="hljs-string">&quot;npr&quot;</span>+filename <br>variable = <span class="hljs-string">&quot;elevation&quot;</span>  <br>outRaster = OutputFolder + <span class="hljs-string">&quot;/&quot;</span> + fileroot  <br><br><span class="hljs-comment"># Process: Make NetCDF Raster Layer  </span><br>arcpy.MakeNetCDFRasterLayer_md(inNCfiles, <span class="hljs-string">&quot;elevation&quot;</span>, <span class="hljs-string">&quot;lon&quot;</span>, <span class="hljs-string">&quot;lat&quot;</span>, variable, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;BY_VALUE&quot;</span>)  <br><br><span class="hljs-comment"># Process: Copy Raster  </span><br>arcpy.CopyRaster_management(variable, outRaster + <span class="hljs-string">&quot;.tif&quot;</span>, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;NONE&quot;</span>, <span class="hljs-string">&quot;NONE&quot;</span>, <span class="hljs-string">&quot;&quot;</span>)  <br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
